// controllers/upgradeorchestrator_controller.go
package controllers

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	policyv1 "k8s.io/api/policy/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/apimachinery/pkg/util/wait"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	apps "github.com/nachoperator/nacho-operators/upgrade-orchestrator/api/v1alpha1"
)

type UpgradeOrchestratorReconciler struct {
	client.Client
}

func (r *UpgradeOrchestratorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx).WithValues("upgradeOrchestrator", req.NamespacedName)

	logger.Info("Starting reconciliation loop")

	var orchestrator apps.UpgradeOrchestrator
	if err := r.Get(ctx, req.NamespacedName, &orchestrator); err != nil {
		logger.Error(err, "failed to get UpgradeOrchestrator object")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	targetVersion, err := r.detectTargetVersion(ctx)
	if err != nil {
		logger.Error(err, "failed to detect target GKE version")
		return ctrl.Result{RequeueAfter: 10 * time.Second}, nil
	}
	logger.Info("Detected target node version", "version", targetVersion)

	for _, dep := range orchestrator.Spec.Deployments {
		obj, err := r.getWorkload(ctx, req.Namespace, dep.Name)
		if err != nil {
			logger.Error(err, "workload not found", "name", dep.Name)
			continue
		}

		logger.Info("Ensuring PDB exists", "deployment", dep.Name)
		err = r.createPDB(ctx, req.Namespace, dep.Name, obj.GetSelector())
		if err != nil {
			if apierrors.IsAlreadyExists(err) {
				logger.Info("PDB already exists", "deployment", dep.Name)
			} else {
				logger.Error(err, "failed to create PDB", "deployment", dep.Name)
			}
			continue
		}
		logger.Info("PDB created", "deployment", dep.Name)
	}

	for _, dep := range orchestrator.Spec.Deployments {
		if isDone(&orchestrator, dep.Name) {
			logger.Info("Skipping completed deployment", "deployment", dep.Name)
			continue
		}
		if !dependenciesMet(&orchestrator, dep.DependsOn) {
			logger.Info("Skipping deployment; dependencies not met", "deployment", dep.Name)
			continue
		}

		obj, err := r.getWorkload(ctx, req.Namespace, dep.Name)
		if err != nil {
			logger.Error(err, "workload not found", "deployment", dep.Name)
			continue
		}

		logger.Info("Patching affinity to target version", "deployment", dep.Name)
		if err := r.patchAffinity(ctx, obj, targetVersion); err != nil {
			logger.Error(err, "failed to patch affinity", "deployment", dep.Name)
			continue
		}
		logger.Info("Affinity patched successfully", "deployment", dep.Name)

		logger.Info("Waiting for rollout to complete", "deployment", dep.Name)
		if err := r.waitForRollout(ctx, obj); err != nil {
			logger.Error(err, "rollout failed", "deployment", dep.Name)
			continue
		}
		logger.Info("Rollout complete", "deployment", dep.Name)

		logger.Info("Cleaning up affinity and PDB", "deployment", dep.Name)
		if err := r.cleanup(ctx, obj); err != nil {
			logger.Error(err, "cleanup failed", "deployment", dep.Name)
			continue
		}
		logger.Info("Cleanup completed", "deployment", dep.Name)

		markAsDone(&orchestrator, dep.Name)
		if err := r.Status().Update(ctx, &orchestrator); err != nil {
			logger.Error(err, "failed to update status", "deployment", dep.Name)
		} else {
			logger.Info("Marked as done", "deployment", dep.Name)
		}
	}

	logger.Info("Reconciliation loop completed")
	return ctrl.Result{RequeueAfter: 30 * time.Second}, nil
}

// func (r *UpgradeOrchestratorReconciler) detectTargetVersion(ctx context.Context) (string, error) {
// 	var nodes corev1.NodeList
// 	if err := r.List(ctx, &nodes); err != nil {
// 		return "", err
// 	}
// 	versionCount := map[string]int{}
// 	for _, node := range nodes.Items {
// 		version := node.Status.NodeInfo.KubeletVersion
// 		versionCount[version]++
// 	}
// 	if len(versionCount) != 2 {
// 		return "", fmt.Errorf("expected 2 versions during upgrade, got: %v", versionCount)
// 	}
// 	var target string
// 	max := 0
// 	for version, count := range versionCount {
// 		if count > max {
// 			max = count
// 			target = version
// 		}
// 	}
// 	return target, nil
// }

func (r *UpgradeOrchestratorReconciler) detectTargetVersion(ctx context.Context) (string, error) {
	var nodes corev1.NodeList
	if err := r.List(ctx, &nodes); err != nil {
		return "", err
	}
	versionSet := map[string]struct{}{}
	for _, node := range nodes.Items {
		version := node.Status.NodeInfo.KubeletVersion
		versionSet[version] = struct{}{}
	}

	if len(versionSet) != 2 {
		return "", fmt.Errorf("expected 2 versions during upgrade, got: %v", versionSet)
	}

	var versions []string
	for v := range versionSet {
		versions = append(versions, v)
	}

	// Simple comparación lexicográfica; si las versiones tienen formato semver, se puede mejorar
	if versions[0] > versions[1] {
		return versions[0], nil
	}
	return versions[1], nil
}

func (r *UpgradeOrchestratorReconciler) getWorkload(ctx context.Context, ns, name string) (*genericWorkload, error) {
	ss := &appsv1.StatefulSet{}
	if err := r.Get(ctx, types.NamespacedName{Namespace: ns, Name: name}, ss); err == nil {
		return &genericWorkload{kind: "StatefulSet", namespace: ns, name: name, selector: ss.Spec.Selector, template: &ss.Spec.Template}, nil
	}
	dep := &appsv1.Deployment{}
	if err := r.Get(ctx, types.NamespacedName{Namespace: ns, Name: name}, dep); err == nil {
		return &genericWorkload{kind: "Deployment", namespace: ns, name: name, selector: dep.Spec.Selector, template: &dep.Spec.Template}, nil
	}
	return nil, fmt.Errorf("workload %s not found", name)
}

type genericWorkload struct {
	kind      string
	namespace string
	name      string
	selector  *metav1.LabelSelector
	template  *corev1.PodTemplateSpec
}

func (w *genericWorkload) GetSelector() *metav1.LabelSelector {
	return w.selector
}

func (r *UpgradeOrchestratorReconciler) patchAffinity(ctx context.Context, w *genericWorkload, version string) error {
	logger := log.FromContext(ctx).WithValues("workload", w.name)

	patchPayload := map[string]interface{}{
		"spec": map[string]interface{}{
			"template": map[string]interface{}{
				"spec": map[string]interface{}{
					"affinity": map[string]interface{}{
						"nodeAffinity": map[string]interface{}{
							"requiredDuringSchedulingIgnoredDuringExecution": map[string]interface{}{
								"nodeSelectorTerms": []interface{}{
									map[string]interface{}{
										"matchExpressions": []interface{}{
											map[string]interface{}{
												"key":      "kubernetes.io/kubelet-version",
												"operator": "In",
												"values":   []string{version},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}

	patchBytes, err := json.Marshal(patchPayload)
	if err != nil {
		logger.Error(err, "failed to marshal affinity patch")
		return err
	}

	var obj client.Object
	if w.kind == "StatefulSet" {
		obj = &appsv1.StatefulSet{ObjectMeta: metav1.ObjectMeta{Namespace: w.namespace, Name: w.name}}
	} else {
		obj = &appsv1.Deployment{ObjectMeta: metav1.ObjectMeta{Namespace: w.namespace, Name: w.name}}
	}

	err = r.Patch(ctx, obj, client.RawPatch(types.StrategicMergePatchType, patchBytes))
	if err != nil {
		logger.Error(err, "failed to patch object")
	}
	return err
}

func (r *UpgradeOrchestratorReconciler) waitForRollout(ctx context.Context, w *genericWorkload) error {
	logger := log.FromContext(ctx).WithValues("workload", w.name)

	return wait.PollUntilContextTimeout(ctx, 5*time.Second, 5*time.Minute, true, func(ctx context.Context) (bool, error) {
		if w.kind == "StatefulSet" {
			ss := &appsv1.StatefulSet{}
			err := r.Get(ctx, types.NamespacedName{Namespace: w.namespace, Name: w.name}, ss)
			if err != nil {
				logger.Error(err, "failed to get StatefulSet during rollout")
				return false, err
			}
			logger.Info("Checking rollout status", "readyReplicas", ss.Status.ReadyReplicas, "expectedReplicas", *ss.Spec.Replicas)
			return ss.Status.ReadyReplicas == *ss.Spec.Replicas, nil
		}
		dep := &appsv1.Deployment{}
		err := r.Get(ctx, types.NamespacedName{Namespace: w.namespace, Name: w.name}, dep)
		if err != nil {
			logger.Error(err, "failed to get Deployment during rollout")
			return false, err
		}
		logger.Info("Checking rollout status", "readyReplicas", dep.Status.ReadyReplicas, "expectedReplicas", *dep.Spec.Replicas)
		return dep.Status.ReadyReplicas == *dep.Spec.Replicas, nil
	})
}

func (r *UpgradeOrchestratorReconciler) createPDB(ctx context.Context, ns, name string, selector *metav1.LabelSelector) error {
	logger := log.FromContext(ctx).WithValues("pdb", name)
	pdb := &policyv1.PodDisruptionBudget{
		ObjectMeta: metav1.ObjectMeta{Name: fmt.Sprintf("block-%s", name), Namespace: ns},
		Spec: policyv1.PodDisruptionBudgetSpec{
			MinAvailable: &intstr.IntOrString{Type: intstr.String, StrVal: "100%"},
			Selector:     selector,
		},
	}
	err := r.Create(ctx, pdb)
	if err != nil {
		logger.Error(err, "failed to create PDB")
	} else {
		logger.Info("PDB created successfully")
	}
	return err
}

func (r *UpgradeOrchestratorReconciler) cleanup(ctx context.Context, w *genericWorkload) error {
	logger := log.FromContext(ctx).WithValues("cleanup", w.name)

	patchPayload := map[string]interface{}{
		"spec": map[string]interface{}{
			"template": map[string]interface{}{
				"spec": map[string]interface{}{
					"affinity": nil,
				},
			},
		},
	}
	patchBytes, _ := json.Marshal(patchPayload)

	var obj client.Object
	if w.kind == "StatefulSet" {
		obj = &appsv1.StatefulSet{ObjectMeta: metav1.ObjectMeta{Namespace: w.namespace, Name: w.name}}
	} else {
		obj = &appsv1.Deployment{ObjectMeta: metav1.ObjectMeta{Namespace: w.namespace, Name: w.name}}
	}

	if err := r.Patch(ctx, obj, client.RawPatch(types.StrategicMergePatchType, patchBytes)); err != nil {
		logger.Error(err, "failed to remove affinity")
	} else {
		logger.Info("Affinity removed")
	}

	pdbName := fmt.Sprintf("block-%s", w.name)
	if err := r.Delete(ctx, &policyv1.PodDisruptionBudget{ObjectMeta: metav1.ObjectMeta{Name: pdbName, Namespace: w.namespace}}); err != nil {
		logger.Error(err, "failed to delete PDB")
	} else {
		logger.Info("PDB deleted")
	}

	return nil
}

func dependenciesMet(or *apps.UpgradeOrchestrator, deps []string) bool {
	for _, d := range deps {
		if !isDone(or, d) {
			return false
		}
	}
	return true
}

func isDone(or *apps.UpgradeOrchestrator, name string) bool {
	return or.Annotations["done-"+name] == "true"
}

func markAsDone(or *apps.UpgradeOrchestrator, name string) {
	if or.Annotations == nil {
		or.Annotations = map[string]string{}
	}
	or.Annotations["done-"+name] = "true"
}

func (r *UpgradeOrchestratorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&apps.UpgradeOrchestrator{}).
		Complete(r)
}
